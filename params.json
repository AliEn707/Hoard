{"name":"Hoard","tagline":"The Hoard Memory Allocator: A Fast, Scalable, and Memory-efficient Malloc for Linux, Windows, Mac, and Solaris.","body":"__if downloading from GitHub, make sure to use `--recursive`, as in:__\r\n    `git clone --recursive https://github.com/emeryberger/Hoard`\r\n\r\n\r\n[The Hoard Memory Allocator](http://www.hoard.org)\r\n--------------------------\r\n\r\nCopyright (C) 1998-2014 by [Emery Berger](http://www.cs.umass.edu/~emery)\r\n\r\nThe Hoard memory allocator is a fast, scalable, and memory-efficient\r\nmemory allocator for Linux, Solaris, Mac OS X, Windows, and\r\nmore.\r\n\r\nHoard is a drop-in replacement for malloc that can dramatically\r\nimprove application performance, especially for multithreaded programs\r\nrunning on multiprocessors and multicore CPUs. No source code changes\r\nnecessary: just link it in or set one environment variable (see\r\n[Building Hoard](#building-hoard-unixmac), below).\r\n\r\nPress\r\n-----\r\n\r\n*   \"If you'll be running on multiprocessor machines, ... use Emery\r\nBerger's excellent Hoard multiprocessor memory management code. It's a\r\ndrop-in replacement for the C and C++ memory routines and is very fast\r\non multiprocessor machines.\"\r\n\r\n    * [Debugging Applications for Microsoft .NET and Microsoft Windows, Microsoft Press](http://www.microsoft.com/mspress/books/5822.aspx)\r\n\r\n*   \"(To improve scalability), consider an open source alternative such as\r\nthe Hoard Memory Manager...\"\r\n\r\n    * [Windows System Programming, Addison-Wesley](http://www.amazon.com/Windows-Programming-Addison-Wesley-Microsoft-Technology/dp/0321657748/)\r\n\r\n*   \"Hoard dramatically improves program performance through its more\r\nefficient use of memory. Moreover, Hoard has provably bounded memory\r\nblowup and low synchronization costs.\"\r\n\r\n    * [Principles of Parallel Programming, Addison-Wesley](http://www.amazon.com/Principles-Parallel-Programming-Calvin-Lin/dp/0321487907/)\r\n\r\nUsers\r\n-----\r\n\r\nCompanies using Hoard in their products and servers include AOL,\r\nBritish Telecom, Blue Vector, Business Objects (formerly Crystal\r\nDecisions), Cisco, Credit Suisse, Entrust, InfoVista, Kamakura,\r\nNovell, Oktal SE, OpenText, OpenWave Systems (for their Typhoon and\r\nTwister servers), Pervasive Software, Plath GmbH, Quest Software,\r\nReuters, Royal Bank of Canada, SAP, Sonus Networks, Tata\r\nCommunications, and Verite Group.\r\n\r\nOpen source projects using Hoard include the Asterisk Open Source\r\nTelephony Project, Bayonne GNU telephony server, the Cilk parallel\r\nprogramming language, the GNU Common C++ system, the OpenFOAM\r\ncomputational fluid dynamics toolkit, and the SafeSquid web proxy.\r\n\r\nHoard is now a standard compiler option for the Standard Performance\r\nEvaluation Corporation's CPU2006 benchmark suite for the Intel and\r\nOpen64 compilers.\r\n\r\nLicensing\r\n---------\r\n\r\nHoard is distributed under the GPL (v2.0), and can also be licensed\r\nfor commercial use.\r\n\r\nBecause of the restrictions imposed by the GPL license (you must make\r\nyour code open-source), commercial users of Hoard can purchase non-GPL\r\nlicenses through the University of Texas at Austin. Please consult the\r\n[current Hoard pricing\r\ninformation](http://www.cs.umass.edu/~emery/hoard/Hoard%20Pricing%202-05-2009.pdf)\r\n(updated 2/5/2009), which lists a number of options for purchasing\r\nlicenses, as well as [software license terms and\r\nconditions](http://www.cs.umass.edu/~emery/hoard/SLA%20Terms%20and%20Conditions%209.22.2006.pdf),\r\nand the [software license\r\nagreement](http://www.cs.umass.edu/~emery/hoard/SLA%20Short%20Form%209-26-2006.pdf):\r\nnote that the [main UT-Austin licensing\r\npage](http://www.otc.utexas.edu/IndustryForms.jsp) always contains the\r\nmost up-to-date documents.\r\n\r\nTo obtain a license, please contact Jitendra Jain directly\r\n(jjain@otc.utexas.edu) and copy Emery Berger (emery@cs.umass.edu).\r\n\r\nJitendra Jain's full contact information follows:\r\n\r\nJitendra Jain  \r\nThe University of Texas at Austin  \r\nOffice of Technology Commercialization  \r\nMCC Building, Suite 1.9A  \r\n3925 West Braker Lane  \r\nAustin, Texas 78759  \r\n(512) 471-9055, (512) 475-6894 (fax)  \r\n\r\n\r\nWhy Hoard?\r\n----------\r\n\r\nThere are a number of problems with existing memory allocators that\r\nmake Hoard a better choice.\r\n\r\n### Contention ###\r\n\r\n\r\nMultithreaded programs often do not scale because the heap is a\r\nbottleneck. When multiple threads simultaneously allocate or\r\ndeallocate memory from the allocator, the allocator will serialize\r\nthem. Programs making intensive use of the allocator actually slow\r\ndown as the number of processors increases. Your program may be\r\nallocation-intensive without you realizing it, for instance, if your\r\nprogram makes many calls to the C++ Standard Template Library (STL).\r\n\r\n### False Sharing ###\r\n\r\nThe allocator can cause other problems for multithreaded code. It can\r\nlead to false sharing in your application: threads on different CPUs\r\ncan end up with memory in the same cache line, or chunk of\r\nmemory. Accessing these falsely-shared cache lines is hundreds of\r\ntimes slower than accessing unshared cache lines.\r\n\r\n### Blowup ###\r\n\r\nMultithreaded programs can also lead the allocator to blowup memory\r\nconsumption. This effect can multiply the amount of memory needed to\r\nrun your application by the number of CPUs on your machine: four CPUs\r\ncould mean that you need four times as much memory. Hoard is a fast\r\nallocator that solves all of these problems.\r\n\r\nTechnical Information\r\n---------------------\r\n\r\nFor technical details of a previous version of Hoard, read [Hoard: A\r\nScalable Memory Allocator for Multithreaded Applications](http://dl.acm.org/citation.cfm?id=379232),\r\nby Emery D. Berger, Kathryn S. McKinley, Robert D. Blumofe, and Paul\r\nR. Wilson. The Ninth International Conference on Architectural Support\r\nfor Programming Languages and Operating Systems\r\n(ASPLOS-IX). Cambridge, MA, November 2000.\r\n\r\nBuilding Hoard (Unix/Mac)\r\n-------------------------\r\n\r\n**NOTE: Make sure to invoke git as follows: `git clone --recursive https://github.com/emeryberger/Hoard.git`**\r\n\r\nTo build Hoard on non-Windows platforms, change into the `src/`\r\ndirectory and run `make` followed by the appropriate target. If you\r\ntype `make`, it will present a list of available targets. These\r\ninclude `linux-gcc-x86`, `solaris-sunw-sparc`, `macos`, `windows`, and\r\nmore.\r\n\r\n\t% make linux-gcc-x86-64\r\n\r\nYou can then use Hoard by linking it with your executable, or\r\nby setting the `LD_PRELOAD` environment variable, as in\r\n\r\n\t% export LD_PRELOAD=/path/to/libhoard.so\r\n\r\nin Solaris:\r\n\r\n\t% make solaris-sunw-sparc\r\n\t% export LD_PRELOAD=\"/path/to/libhoard_32.so:/usr/lib/libCrun.so.1\"\r\n\r\n  (32-bit version)\r\n\r\n\t% export LD_PRELOAD=\"/path/to/libhoard_64.so:/usr/lib/64/libCrun.so.1\"\r\n  (64-bit version)\r\n\r\nor, in Mac OS X:\r\n\r\n\t% make macos\r\n\t% export DYLD_INSERT_LIBRARIES=/path/to/libhoard.dylib\r\n\r\nBuilding Hoard (Windows)\r\n------------------------\r\n\r\nChange into the `src` directory and build the Windows version:\r\n\r\n\tC:\\hoard\\src> nmake windows\r\n\r\nTo use Hoard, link your executable with `source\\uselibhoard.cpp` and `libhoard.lib`.\r\nYou *must* use the `/MD` flag.\r\n\r\nExample:\r\n\r\n\tC:\\hoard\\src> cl /Ox /MD yourapp.cpp source\\uselibhoard.cpp libhoard.lib\r\n\r\nTo run `yourapp.exe`, you will need to have `libhoard.dll` in your path.\r\n\r\n\r\nBenchmarks\r\n----------\r\n\r\nThe directory `benchmarks/` contains a number of benchmarks used to\r\nevaluate and tune Hoard.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}